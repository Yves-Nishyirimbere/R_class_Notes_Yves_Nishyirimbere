---
title: "Class Two by Dr. Pacifique NIZEYIMANA"

author: "NISHYIRIMBERE Yves_101388"
Lecturer: "Dr.pacifigue"
date: "`r Sys.Date()`"
---


Data Management

Data Visualization and Data management

Test to treat data

```{r}
data1 <- read.table(text = "
Sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
4 6 30 140 67 47 23 39 134 80
10 2 29 164 72 81 28 63 211 132
", header = TRUE)
barplot(as.matrix(data1),main="Confirmed cases Vs Gender",beside=TRUE,col=c("gold3","red"))
legend("topright", c("Male","Female"),cex = 0.5,bty="n",fill = c("gold3","red"))

```

```{r}
data3 <- read.table(text = "
sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
867 582 1802 12003 3059 9205 5346 7269 5933 3245
842 436 1805 11785 3508 10908 4902 7883 5901 4646
", header = TRUE)
barplot(as.matrix(data3),main=" COVID 19 test Vs Gender",beside=TRUE,col=c("blue","purple"))
legend("topleft", c("Male","Female"),cex = 1.3,bty="n",fill = c("blue","purple"))

```


```{r}
data2 <- read.table(text = "
Sept_2022 Oct_2022 Nov_2022 Dec_2022 Jan_2023 Feb_2023 Mar_2023 Apr_2023 May_2023 June_2023
0 0 1 9 8 7 1 4 11 22
11 3 41 242 104 78 44 86 244 147
3 5 17 53 27 43 6 12 90 43
", header = TRUE)
barplot(as.matrix(data2),main="Confirmed cases Vs Age categories",beside=TRUE,col=c("green","blue","purple"))
barplot(as.matrix(data2),main="Confirmed cases Vs Age categories",beside=TRUE,col=c("green","blue","purple"))
legend("topleft", c("Less than 15 years","15-49 years","Above 50"),cex= 1.3,bty="n",fill = c("green","blue","purple"))
```
```{r}
months<-c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023")
Confirmed_covid<-c(14,8,59,304,139,128,51,102,345,212)
Confirmed_covid<-c(14,8,59,304,139,128,51,102,345,212)
plot(Confirmed_covid, type = "l",pch=21, col = "red",ylim=c(0,350),
xaxt="n", ylab = "Number of patients ",
main = "Confirmed cases Vs treatment ")
treatment<- c(12,0,26,217,104,57,12,47,23,20)
lines(treatment, col="blue",lty=2)
legend("topleft", legend=c("Received treatment", "Confirmed"),cex=0.5,fill = c("blue","red"))
axis(1,at=1:10,lab=c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023"))
```


```{r}
months<-c("sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","feb_2023","Mar_2023","Apr_2023","May_2023", "June_2023")
number_of_test<-c(1709, 1018, 3607,23788,6567,20113,10248,15152,11834,7891)
plot(number_of_test, type = "o", col = "blue",ylim=c(0,24000),
xaxt="n", ylab = "Number of Test",
main = "COVID 19 Test")
axis(1,at=1:10,lab=c("Sept_2022","Oct_2022","Nov_2022","Dec_2022", "Jan_2023","Feb_2023","Mar_2023","Apr_2023","May_2023","June_2023"))
```
ggplot2

ggplot2 provides a set of tools that allows you to visualize complex data sets in a new creative way -some work need some package to get one. some of the graph are created using R's base graphics syste.

Library ggplot2
```{r}
###install.packages("ggplot2")
library(ggplot2)

```
let us explore the data mcars
```{r}
data("mtcars")
#dotchart(mtcars$mpg,labels=row.names(mtcars),ce#x = 0.,main="miles perGallon of car #model",xlab = "MPG")
table(mtcars$cyl)
```
```{r}
#barplot(mtcars$cyl)
barplot(table(mtcars$cyl),main="Distribution of car Cylinder counts",xlab="Number of cylinders",ylab = "Number of cars")
```
```{r}
barplot(table(mtcars$cyl),main="Distribution of car Cylinder counts",xlab="Number of cylinders",ylab = "Number of cars",horiz=TRUE)
```
```{r}
plot(mtcars$mpg~mtcars$wt,main="Automobile Data",xlab="Weight",ylab="Miles per Gallon")
```
```{r}
plot(mtcars$mpg~mtcars$wt,main="Automobile Data",xlab="Weight",ylab="Miles per Gallon")
plot(mtcars$mpg~mtcars$wt,pch=17,main="Automobile Data",xlab="Weight",ylab=" Miles per Gallon")
```
```{r}
plot(mtcars$mpg~mtcars$wt,pch=21,main="Automobile Data",xlab="Weight",ylab="Miles per Gallon") 
```
```{r}
plot(mtcars$mpg~mtcars$wt,type="l", lty=2, lwd=2,col="red",main="Automobile Data",xlab="Weight",ylab="Miles per Gallon")
```
in ggplot2, plots are created by chaining together function using (+)sign. Each functionmodify the


```{r}
##plot created up to that point
library(ggplot2)
ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point()+
labs(title = "Automobile Data",x="Weight",y="Miles per Galon")
```
```{r}
ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point(pch=17,color="blue",size=1)+
geom_smooth(method="lm",color="green")+
labs(title = "Automobile Data",x="Weight",y="Miles per Galon")
## `geom_smooth()` using formula = 'y ~ x'
```
```{r}
f0<-ggplot(data=mtcars, aes(x=wt,y=mpg))+geom_point(shape=24, fill=1,size=1)+
geom_smooth(method="lm",color="blue")
f0
## `geom_smooth()` using formula ='y~x'
```
```{r}
f1<-f0+theme_bw()
f1
## `geom_smooth()` using formula = 'y ~ x'
```
```{r}
f2<-f1+
theme(panel.grid = element_line(linetype = "dotted",color = "Black"))
f2
## `geom_smooth()` using formula = 'y ~ x'
```
```{r}
# Grouping displays two or more groups of observations in a single plot
data(mtcars)
mtcars$am<-factor(mtcars$am, levels =c(0,1),
labels= c("Automatic","Manual"))
mtcars$vs<-factor(mtcars$vs, levels =c(0,1),
labels=c("V-Engine","Straight Engine"))
mtcars$cyl<-factor(mtcars$cyl)
ggplot(data=mtcars,aes(x=hp,y=mpg,shape=cyl,color=cyl))+
geom_point(size=3)+
facet_grid(vs~am)+
labs(title = "Automobile Data by Engine Type",x="HorsePower",y="Milesper Gallon")
```
```{r}
data(singer,package="lattice")
ggplot(singer,aes(x=voice.part,y=height))+geom_boxplot()
```
Use the following function:
geom_bar() geom_boxplot() geom_density() geom_histogram() geom_hline()
geom_jitter() geom_line() #geom_point() geom_rug() #geom_smooth() geom_text() geom_violin() geom_vline  Basic data management

##. cbind and rbind

While combining column wise, the number of rows must match but row names are ignored. when combining row-wise, both the number and the names of columns must match.

```{r}

data2<- data.frame(x=1:3, y=c("a","b","c"))
str(data2)
## 'data.frame': 3 obs. of 2 variables:
## $ x: int 1 2 3
## $ y: chr "a" "b" "c"
```
```
``{r}
(cbind(data2,data.frame(z=3:1)))
```

```{r}
(rbind(data2,data.frame(x=10,y="z")))
```
Create another Variable

```{r}
data_class<-read.table("/Users/nishyirimbereyves/Downloads/class_data.txt",header = TRUE) 
variable.names(data_class) 
tail(data_class)
```

```{r}
data_class[,1]
```

```{r}
summary(data_class$Weight)
```
```{r}
length(data_class$Weight)
```
```{r}
data_class[,-1]
```

```{r}
attach(data_class)
(BMI<-Weight/(Height/100)^2)
```
```{r}
(BMI<-round(Weight/(Height/100)^2,digit=1))
```

```{r}
head(cbind(data_class,BMI))
```
```{r}
tail(cbind(data_class,BMI),n=10)
```
detach(data_class)

```{r}
#Summary of BMI
summary(BMI)
```
```{r}
hist(data_class$Height)
```
```{r}
hist(data_class$Weight,col = "blue",main = "Sample Histogram")
```
```{r}
stem(BMI,scale=2)
```
Subsetting
Use of $, []. or [[]]
Creation of leadership data Interest: How men and women differ in the way theylead their organizations. 5 questions were asked in this study. Example of the
question: Do men and women in management position differ in the degree to whichthey defer to superiors? 1: strongly disagree, 2: disagree, 3:neither agree nor
disagree,4: agree, 5: strongly agree

```{r}
manager <- c(1,2,3,4,5)
country<- c("US","US","UK","UK","UK")
gender<-c("M","F","F","M","F")
age<-c(32,45,25,39,99)
q1<-c(5,3,3,3,2)
q2<-c(4,5,5,3,2)
q3<-c(5,2,5,4,1)
q4<-c(5,5,5,NA,2)
q5<-c(5,5,2,NA,1)
leadership<-data.frame(manager,country, gender, age, q1,q2,q3,q4,q5,stringsAsFactors = FALSE)
leadership<-data.frame(manager,country, gender, age, q1,q2,q3,q4,q5)
str(leadership)
```
```{r}
names(leadership)
```
What you can do - combine the score of the five questions -handle the missing values - create a dataset of what you want -create age group or age categories - 99 indicate the value is missing

#### Missing value
```{r}
leadership$age[leadership$age == 99] <- NA
leadership$agecat[leadership$age > 75] <- "Elder"
leadership$agecat[leadership$age >= 35 & leadership$age <= 75] <- "Middle Aged"
leadership$agecat[leadership$age < 35] <- "Young"

```



####. One way to handle missing value


Deleting all observations with missing data ( Listwise deletion) is one of the several methods of handling incomplete datasets. Note: You can also replacing the missing value by the average of the remaining data.
```{r}
is.na(leadership[,5:9])
```
```{r}
newdata<-na.omit(leadership) 
newdata
```
Sorting data
```{r}

order(leadership$age) ## [1] 3 1 4 2 5 newdata2<-leadership[order(leadership$age),]
newdata2<-leadership[order(leadership$age),]

```

Merging data sets
To merge two data frame horizontally, you use merge() function. In most cases, two data frames are joined by one or more common key variables. -example 1: merge(dataframeA, dataframeB,by=“ID”) -example 2: merge(dataframeA,dataframeB, by=c(“ID”,“country”)) the second merge the two dataframes by ID and country
To join two data frame( datasets) vertically, use rbind() function: Note that the two data set must have the same variables

Subset (selecting variables,dropping variables,selecting observation )

```{r}
newdata3<-leadership[,c(5:9)] 
myvars<-c("q1","q2","q3","q4","q5") 
newdata3<-leadership[myvars] 
newdata4<-leadership[,c(-1,-2)] 
newdata4<-leadership[,-(1:5)] 
newdata5<-leadership[,c(-1,-7)] 
leadership[[4]]
```
```{r}
leadership$age
```
```{r}
newdata6<-leadership[c(-1,-3),] 
newdata6<-leadership[c(2,4,5),] 
newdata7<-subset(leadership,age>=35|age<24,select=c(q1,q2,q3,q4,q5))
attach(leadership)
```
```{r}
#newdata7<-leadership[gender="M" & age>30,]
newdata7<-leadership[gender=="M" & age>30,]
detach(leadership)
```

### Data management with dyplr
Data source from the package nycflights13 and ggplot2 This data contains all 336,776 flights that departed from New York city in 2013.
```{r}
#install.packages("nycflights13") 
#install.packages("tidyverse") 
library(nycflights13)
library(dplyr)


```
```{r}
library(tidyverse)
```
The function filter()
```{r}
#rm(list=ls())
str(flights)
```
```{r}
attach(flights)
jan<-filter(flights,month==1)
jan
```

```{r}
newyear<-filter(flights,month==1,day==1)
newyear
```
```{r}
dec25<-filter(flights,month==12,day==25)
dec25
```

```{r}
jan_dec<-filter(flights,month==1|month==12)
jan_dec
```
```{r}
nov_dec<-filter(flights,month %in% c(11,12))
#detach(flights)
```

The function arrange()
This change the order

```{r}
data_10<-arrange(flights,year,month,day)
arrange(flights,desc(arr_delay))
```
The function select
This helps to selects only the variables you are interested in

```{r}


time_var<-select(flights, year,month, day)
select(flights, year:day)
```
```{r}
select(flights,-(year:day))
```
The function mutate
This is useful in adding a new Variable

```{r}
## create a small data set
flights2<-select(flights,year:day,ends_with("delay"),distance,air_time)
(mutate(flights2,gain=arr_delay-dep_delay,speed=distance/air_time*60))
```



# Class _2 CONTINUED 

## Control structures

# Grouping

Control structures in R allow you to control the flow of execution of a series of R
expressions. Basically, control structures allow you to put some “logic” into your R
code, rather than just always executing the same R code every time. Control
structures allow you to respond to inputs or to features of the data and execute
different R expressions accordingly. Commonly used control structures are • if and
else: testing a condition and acting on it • for: execute a loop a fixed number of times
• while: execute a loop while a condition is true • repeat: execute an infinite loop
(must break out of it to stop) • break: break the execution of a loop • next: skip an
interaction of a loop


if (condition){ ## do something } ## continue with the rest of the code. if( condition){ do something
} else { do something else
}
You can also create a series of test by following the initial if with a number of elseifsif(condition){ do something
}else if (condition 2){ Do something different }else{ do something different }

## Function on R
```{r}
f<-function(x) x^2
formals(f)
body(f)
environment(f)


```

#ifelse(test,yes,No)
```{r}
pvalues<-c(.867,0.0054,0.0018,0.1572,0.0183,0.5386)
results<-ifelse(pvalues<0.05,"Significant"," Not significant")
results

```


```{r}
x<-runif(1,0,10)
if(x>3){
y<-10
}else {
y<-0
}
```

# The value of y is a set depending on whether x>3 or not. This can also be achieved
```{r}
y<-if (x>3){
10
}else {
0

}
```

## For
```{r}
for(i in 1:10){
print(i)
}
x<-c("a","b","c","d")
x[3]

for(i in 1:5){
print(x[i])
}

for(i in 1:5)print(1:i)
for(i in 5:1)print(1:i)
```
## while Loops
It begins by testing a condition, if it is true, then they execute the loop body. once the loop body is executed,the condition is tested again, until the condition is false. after
which the loop exits.

```{r}
count<-1
while (count<10){
print(count)
count<-count+1
}

z<-5
set.seed(1)
while(z>= 3 && z<=10){
coin<-rbinom(1,1,0.5)
if (coin==1){
z=z+1
} else {
  z<-z-1
}
}
print(z)

```

# next, break
This is used to skip an iteration of a loop


```{r}
for (i in 1:100){
print(1:i)
if (i>20){
  break
}
}

```

## Function
functionname<-function(parameters){ statements return(value) }
f1<-function(x){ result<-x^2+2 return(result) }
f2<-function(x,y){ result<-x
2+y2-4 return(result) }
```{r}
f<-function(x,y){
result<-x+(2*y)+3
return(result)
}
f(2,3)
f(2,3)
```

You can use args() function to view the parameter names and default values
##Exercises
Make functions that calculate summary statistics
Make a function to calculate two sample t test
# Applying functions to matrices and data frame. a<-4

```{r}
a<-4
sqrt(4)
b<- c(1,243,5.754,2.987)
round(b)
c<-matrix(runif(12),nrow=3)
c
log(c)
mean(c)

```

Notice that the mean of matrix c results in a scalar (0.444). the mean() take the
average of all 12 elements in the matrix.But what if you want the three rowmeans
or the four column means?
R provides a function, apply() that allows to apply an arbitrary function to any
dimension of a matrix, array or data frame. The format for the apply() functionis -
apply(x, MARGIN, FUN,…) where x stands for the data object, Margin can be 1(rows)
and 2(columns ) ## Col/Row Sums and Means • rowSums = apply(x, 1, sum) • rowMeans = apply(x, 1, mean) • colSums = apply(x, 2, sum) • colMeans = apply(x, 2, mean)

## lappy function
lapply() takes three inputs:,x,a list,a function, and…, It applies to each element of thelist and returns a new list. lapply(x,f,…). It is called function because it takes functionas an argument. Assume we have a data frame df. instead of assigning the result pf
lappliy() to df, we will assign them to df[] to ensure we get a data frame


```{r}
fix_missing<-function(x){
x[x==-99]<-NA
x
}
function1<-function(x){
x^2
}
curve(function1,-4,4)

#df[]<-lappy(df,fix_missing)
```

It works for any number of columns.There is no way to accidentally miss a column
There is no way to accidentally treat one column differently than another
It easy to generalize this technique to a subset of columns.

```{r}
#df[1:5]<- lapply(df[1:5],fix_missing )
```
## sapply
sapply() and vapply(), variants of lapply() that produces vectors,matrices, andarrays as Output, instead of lists map(), and mapply which iterate over multiple
input data structures in parallel
Another important function when dealing with big data is split() -tapply
# Titanic data
```{r}
str(Titanic)
View(Titanic)
apply(Titanic,c(1,2),sum )

options(digits = 2)
apply(Titanic,c(1,2),sum)[3:4,]
apply(Titanic,c(1,4),sum)[3:4,]
apply(Titanic,c(1,2,4),sum)
#apply(Titanic,c(1,2,4),sum)[3:4,]
apply(Titanic,c(1,2,4),sum)[3:4,,]
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,]
ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,]
digit=2
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin =2)
prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin =2)
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[1:2,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames(Titanic)$Sex))
matrix(prop.table(ftable(apply(Titanic,c(1,4,2),sum)[3:4,,])[3:4,], margin = 2),nrow = 2, dimnames = list(dimnames(Titanic)$Survived,dimnames(Titanic)$Sex))
### Create dataset
Student<-c("John ncuti", "Angela bakame", "Bruce wizeye","Alexis aganze", "claude Rukundo", "Joel Kagabo", "Mary ineza")
Math<-c(600,412,358,495,512,410,522)
Science<-c(95,99,80,82,75,89,77)
English<-c(25,22,18,20,29,30,27)
roster<-data.frame(Student,Math,Science,English,stringsAsFactors = FALSE)
### standardize variables and obtains the performance scores becausethey are reported on different scale( With widely differing means and standard deviations, we need to make them comparable before we combine them.)
z<-scale(roster[,2:4])
### performance of each students using rowmeans and adding them to roster using cbind()
score<-apply(z,1,mean)
roster<-cbind(roster,score)
### Grades the students: quantile function gives the percentile rankof each student's performance score check the cutoff of A
y<-quantile(score,c(.8,.6,.4,.2))
## create a grade variable us
roster$grade[score>=y[1]]<-"A"
roster$grade[score<y[1]&score>=y[2]]<-"B"
roster$grade[score<y[2]& score>=y[3]]<-"C"
roster$grade[score<y[3]& score>=y[4]]<-"D"
roster$grade[score<y[4]]<-"F"
#### Dealing with names
name<-strsplit((roster$Student),"")
lastname<-sapply (name,"[",2)
firstname<-sapply(name,"[",1)
roster<-cbind(firstname, lastname,roster[,-1])
roster<-roster[order(lastname,firstname),]
roster
```

## Aggregation and reshaping
# transpose

```{r}
cars<-mtcars[1:5, 1:4]
cars
t(cars)
```
# aggregate data
aggregate() collapse data in R using one or more by variables and a defined function

```{r}
options(digits=3)
attach(mtcars)
aggdata <- aggregate(. ~ cyl + gear, data = mtcars, FUN = mean)

```

# Reshape
Step 1: install the package reshape2 step 2: melt data step 3: Cast the melted datainto any shape you desire
During the cast, you can aggregate the data with any function you wish. 

```{r}
id<-c(1,1,2,2)
time<-c(1,2,1,2)
x1<-c(5,3,6,2)
x2<-c(6,5,1,4)
mydata<-data.frame(id,time,x1,x2)

```
